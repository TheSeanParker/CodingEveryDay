#################################################################################################################################
#1、给你一个 仅 由字符 'a' 和 'b' 组成的字符串  s 。如果字符串中 每个 'a' 都出现在 每个 'b' 之前，返回 true ；否则，返回 false 。

#示例 1：

#输入：s = "aaabbb"
#输出：true
#解释：
#'a' 位于下标 0、1 和 2 ；而 'b' 位于下标 3、4 和 5 。
#因此，每个 'a' 都出现在每个 'b' 之前，所以返回 true 。
#示例 2：
#输入：s = "abab"
#输出：false


#解释：
#存在一个 'a' 位于下标 2 ，而一个 'b' 位于下标 1 。
#因此，不能满足每个 'a' 都出现在每个 'b' 之前，所以返回 false 。
#示例 3：

#输入：s = "bbb"
#输出：true
#解释：
#不存在 'a' ，因此可以视作每个 'a' 都出现在每个 'b' 之前，所以返回 true 。
###################################################################################################################
#include <string>
#include <vector>
#include <iostream>
using namespace std;
bool judge(string& a)
{
  //
  for(int i=0;i<a.length();i++)
  {
    int count=0;
    if(a[i]=='a')
    {
      count++;
    }
    if(count==a.length()-1)
    {return true;}
  }
  //
  vector<int> a_index(a.length());
  vector<int> b_index(a.length());
      for(int i=0;i<a.length();i++)
  {
       int count=0;
       if(count<a.length())
       {
         if(a[i]=='a')
          {
               count++;
               a_index.push_back(count);
           }
          else
          {
            count++;
            b_index.push_back(count);
          }
       }
  }
 int a_min_index=a_index[0];
 int b_max_index=b_index.pop_back(); 
  if(b_max_index>a_min_index)
    return false;
  return true;
}
int main()
{
  string a="abab"
  std::cout<<"判断结果为："<< judge(a);
}
###################################################################################
#2、给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

#计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

#你可以认为每种硬币的数量是无限的。

#示例 1：

#输入：coins = [1, 2, 5], amount = 11
#输出：3 
#解释：11 = 5 + 5 + 1
#示例 2：

#输入：coins = [2], amount = 3
#输出：-1
#示例 3：

#输入：coins = [1], amount = 0
#输出：-1
#####################################################################################
#amount
#include<iostream>
#include<vector>
using namespace std;
    int count=0;
    int fun(vector<int>& a, int amount)
    { 
      
      if(amount<a[0])
      {
       return -1;
      }
      if(amount>=a[0])
      {
        for(int i=1;i<a.size();i++)
        {
          count=amount/a[a.size()-i];
        	amount=amount%a[a.size()-i];
        }
      }
      return count;
    }
      int main()
       {
         vector<int> test(3)={1,2,5};
         int amount=11;
         std::cout<<"输出"<<fun(test,amount)<<"\n";
       }
#//===================================================================================================
// 将链接分享给你的朋友以加入相同的房间。
// Author: tdzl2003<dengyun@meideng.net>
// QQ-Group: 839088532
//====================================================================================================
//3、数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。
//   请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。//不能用数组（空间复杂度限制），但是可以使用for循环（时间复杂度限制）
//示例 1：

//输入：[1,2,5,9,5,9,5,5,5]
//输出：5
//示例 2：

//输入：[3,2]
//输出：-1
//示例 3：

//输入：[2,2,1,1,1,2,2]
//输出：2

//================================================================================================




//================================================================================================
//4、你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。
//   你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。

//返回的长度需要从小到大排列。

//示例 1

//输入：
//shorter = 1
//longer = 2
//k = 3
//输出： [3,4,5,6]
//解释：
//可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。

//==============================================================================================